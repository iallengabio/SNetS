package measurement;

import network.Circuit;
import network.Link;
import network.Pair;
import request.RequestForConnection;
import simulationControl.resultManagers.BlockingProbResultManager;
import util.IntersectionFreeSpectrum;

import java.util.HashMap;
import java.util.List;

/**
 * This class represents the locking probability metric (general, per pair, per bandwidth, 
 * per pair / BandWidth)
 * The metric represented by this class is associated with a load point and a replication
 *
 * @author Iallen
 */
public class BlockingProbability extends Measurement {

    public final static String SEP = "-";

    // Overall blockage probability
    private int numReqGenGeral;
    private int numReqBlockGeral;
    private int numReqBlockGeralFragment;
    private int numReqBlockGenLackTransmitters;
    private int numReqBlockGenLackReceivers;
    private int numRegBlockQoTGeral;
    private int numRegBlockQoTOtherGeral;
    private int numRegBlockOtherGeral;

    // Blocking probability per pair
    private HashMap<String, Integer> numReqGenPair;
    private HashMap<String, Integer> numReqBlockPair;

    // Blocking probability per bandwidth
    private HashMap<Double, Integer> numReqGenBW;
    private HashMap<Double, Integer> numReqBlockBW;

    // Blocking probability per pair / BandWidth
    private HashMap<String, HashMap<Double, Integer>> numReqGenPairBW;
    private HashMap<String, HashMap<Double, Integer>> numReqBlockPairBW;

    /**
     * Creates a new instance of BlockingProbability
     * 
     * @param loadPoint int
     * @param rep int
     */
    public BlockingProbability(int loadPoint, int rep) {
        super(loadPoint, rep);

        this.numReqGenGeral = 0;
        this.numReqBlockGeral = 0;
        this.numReqBlockGeralFragment = 0;
        this.numReqBlockGenLackTransmitters = 0;
        this.numReqBlockGenLackReceivers = 0;
        this.numRegBlockQoTGeral = 0;
        this.numRegBlockQoTOtherGeral = 0;
        this.numRegBlockOtherGeral = 0;

        this.numReqGenBW = new HashMap<>();
        this.numReqBlockBW = new HashMap<>();
        this.numReqGenPair = new HashMap<>();
        this.numReqBlockPair = new HashMap<>();
        this.numReqGenPairBW = new HashMap<>();
        this.numReqBlockPairBW = new HashMap<>();
        
        fileName = "_BlockingProbability.csv";
		resultManager = new BlockingProbResultManager();
    }

    /**
     * Adds a new observation of block or not a request
     *
     * @param success boolean
     * @param request RequestForConnection
     */
    public void addNewObservation(boolean success, RequestForConnection request) {
    	
    	StringBuilder sbPar = new StringBuilder();
		sbPar.append(request.getPair().getSource().getName());
		sbPar.append(SEP);
		sbPar.append(request.getPair().getDestination().getName());
		String pairName = sbPar.toString();
    	
        // Increment generated general requisitions
        this.numReqGenGeral++;

        // Increment requests generated by pair
        Integer i = this.numReqGenPair.get(pairName);
        if (i == null) i = 0;
        this.numReqGenPair.put(pairName, i + 1);

        // Increment requests generated per bandwidth
        i = this.numReqGenBW.get(request.getRequiredBandwidth());
        if (i == null) i = 0;
        this.numReqGenBW.put(request.getRequiredBandwidth(), i + 1);

        // Increment requests generated by pair / BandWidth
        HashMap<Double, Integer> gplb = this.numReqGenPairBW.get(pairName);
        if (gplb == null) {
            gplb = new HashMap<>();
            this.numReqGenPairBW.put(pairName, gplb);
        }
        i = gplb.get(request.getRequiredBandwidth());
        if (i == null) i = 0;
        gplb.put(request.getRequiredBandwidth(), i + 1);

        // If there is a lock
        if (!success) {
            // Increment blocked requests general
            this.numReqBlockGeral++;

            if (request.getPair().getSource().getTxs().isFullUtilized()) {// Check whether the cause of the block was the lack of transmitters
                this.numReqBlockGenLackTransmitters++;
                
            } else if (request.getPair().getDestination().getRxs().isFullUtilized()) {// Check whether the cause of the block was the lack receirvers
                this.numReqBlockGenLackReceivers++;
                
            } else if (checkFragmentationBlocking(request.getCircuit())) { // Check whether the cause of the block was the fragmentation
                this.numReqBlockGeralFragment++;
                
            }else{
            	this.numRegBlockOtherGeral++;
            }

            // Increase requests blocked by pair
            i = this.numReqBlockPair.get(pairName);
            if (i == null) i = 0;
            this.numReqBlockPair.put(pairName,i + 1);
            
            // Increase requests blocked by bandwidth
            i = this.numReqBlockBW.get(request.getRequiredBandwidth());
            if (i == null) i = 0;
            this.numReqBlockBW.put(request.getRequiredBandwidth(), i + 1);
            
            // Increase request blocked by pair / bandwidth
            HashMap<Double, Integer> bplb = this.numReqBlockPairBW.get(pairName);
            if (bplb == null) {
                bplb = new HashMap<>();
                this.numReqBlockPairBW.put(pairName,bplb);
            }
            i = bplb.get(request.getRequiredBandwidth());
            if (i == null) i = 0;
            bplb.put(request.getRequiredBandwidth(), i + 1);
        }
    }

    /**
     * This method checks whether the blocking occurred by fragmentation.
     * 
     * @param request Circuit
     * @return boolean
     */
    private boolean checkFragmentationBlocking(Circuit request) {
        if (request == null) return false;
        
        List<Link> links = request.getRoute().getLinkList();
        List<int[]> merge = links.get(0).getFreeSpectrumBands();

        for (int i = 1; i < links.size(); i++) {
            merge = IntersectionFreeSpectrum.merge(merge, links.get(i).getFreeSpectrumBands());
        }

        int totalFree = 0;
        for (int[] faixa : merge) {
            totalFree += (faixa[1] - faixa[0] + 1);
        }

        if (totalFree > request.getModulation().requiredSlots(request.getRequiredBandwidth())) {
            return true;
        }

        return false;
    }

    /**
     * Returns the overall blocking probability on the network
     *
     * @return double
     */
    public double getProbBlockGeneral() {
        return ((double) this.numReqBlockGeral / (double) this.numReqGenGeral);
    }

    /**
     * Returns the probability of blocking by fragmentation
     *
     * @return double
     */
    public double getProbBlockFragGeneral() {
        return ((double) this.numReqBlockGeralFragment / (double) this.numReqGenGeral);
    }

    /**
     * Returns the blocking probability due to lack of transmitters
     *
     * @return double
     */
    public double getProbBlockLackTxGen() {
        return ((double) this.numReqBlockGenLackTransmitters / (double) this.numReqGenGeral);
    }

    /**
     * Returns the blocking probability due to lack of receivers
     *
     * @return double
     */
    public double getProbBlockLackRxGen() {
        return ((double) this.numReqBlockGenLackReceivers / (double) this.numReqGenGeral);
    }

    /**
     * Returns the probability of blocking a given pair
     *
     * @return double
     */
    public double getProbBlockPair(Pair p) {
        double res;

        String source = p.getSource().getName();
        String destination = p.getDestination().getName();
        Integer gen = this.numReqGenPair.get(source + SEP + destination);
        if (gen == null)
            return 0; // No requests generated for this pair

        Integer block = this.numReqBlockPair.get(source + SEP + destination);
        if (block == null)
            block = 0;

        res = ((double) block / (double) gen);

        return res;
    }

    /**
     * Returns the blocking probability of a given bandwidth
     *
     * @param bw double
     * @return double
     */
    public double getProbBlockBandwidth(double bw) {
        double res;
        Integer gen = this.numReqGenBW.get(bw);
        if (gen == null)
            return 0; // No requests generated for this pair

        Integer block = this.numReqBlockBW.get(bw);
        if (block == null)
            block = 0;

        res = ((double) block / (double) gen);

        return res;
    }

    /**
     * Returns the blocking probability of a given bandwidth in a given pair
     *
     * @param bw double
     * @return double
     */
    public double getProbBlockPairBandwidth(Pair p, double bw) {
        double res;
        String source = p.getSource().getName();
        String destination = p.getDestination().getName();
        
        Integer gen = null;
        if(this.numReqGenPairBW.get(source + SEP + destination) != null){
        	gen = this.numReqGenPairBW.get(source + SEP + destination).get(bw);
        }
        
        if(gen == null) return 0; // No requests generated for this pair and bandwidth
        Integer block = 0;

        HashMap<Double, Integer> hashAux = this.numReqBlockPairBW.get(source + SEP + destination);
        if (hashAux == null || hashAux.get(bw) == null) {
            block = 0;
        } else {
            block = hashAux.get(bw);
        }

        res = ((double) block / (double) gen);

        return res;
    }

}
